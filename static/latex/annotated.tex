\doxysection{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1Application}{lambda\+::core\+::\+Application}} \\*The mind, body, and soul of Lambda. The \mbox{\hyperlink{classlambda_1_1core_1_1Application}{Application}} class is the }{\pageref{classlambda_1_1core_1_1Application}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1events_1_1AppRenderEvent}{lambda\+::core\+::events\+::\+App\+Render\+Event}} \\*An event generated when the app has rendered }{\pageref{classlambda_1_1core_1_1events_1_1AppRenderEvent}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1events_1_1AppTickEvent}{lambda\+::core\+::events\+::\+App\+Tick\+Event}} \\*An \mbox{\hyperlink{classlambda_1_1core_1_1events_1_1Event}{Event}} generated when the app has ticked }{\pageref{classlambda_1_1core_1_1events_1_1AppTickEvent}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1events_1_1AppUpdateEvent}{lambda\+::core\+::events\+::\+App\+Update\+Event}} \\*An event generated when the app has updated }{\pageref{classlambda_1_1core_1_1events_1_1AppUpdateEvent}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1io_1_1AsyncTask}{lambda\+::core\+::io\+::\+Async\+Task}} \\*A wrapper for callbacks that are supposed to be executed asynchronously }{\pageref{classlambda_1_1core_1_1io_1_1AsyncTask}}{}
\item\contentsline{section}{\mbox{\hyperlink{structlambda_1_1core_1_1renderer_1_1BufferElement}{lambda\+::core\+::renderer\+::\+Buffer\+Element}} \\*A generic buffer element used for describing the layout of a buffer }{\pageref{structlambda_1_1core_1_1renderer_1_1BufferElement}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1renderer_1_1BufferLayout}{lambda\+::core\+::renderer\+::\+Buffer\+Layout}} \\*The layout of a vertex buffer. Should always be instantiated with buffer elements for it to work properly }{\pageref{classlambda_1_1core_1_1renderer_1_1BufferLayout}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1events_1_1Event}{lambda\+::core\+::events\+::\+Event}} \\*The base \mbox{\hyperlink{classlambda_1_1core_1_1events_1_1Event}{Event}} class for events that are propagated throughout lambda }{\pageref{classlambda_1_1core_1_1events_1_1Event}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1events_1_1EventDispatcher}{lambda\+::core\+::events\+::\+Event\+Dispatcher}} \\*The primary way of allowing the application and layers in lambda the capability of handling events propagated throughout the application }{\pageref{classlambda_1_1core_1_1events_1_1EventDispatcher}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1io_1_1EventLoop}{lambda\+::core\+::io\+::\+Event\+Loop}} \\*Asynchronous Event Loop that allows the execution of code to happen in another thread. This is not recommended for production as of yet }{\pageref{classlambda_1_1core_1_1io_1_1EventLoop}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1util_1_1File}{lambda\+::core\+::util\+::\+File}} }{\pageref{classlambda_1_1core_1_1util_1_1File}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1renderer_1_1GraphicsContext}{lambda\+::core\+::renderer\+::\+Graphics\+Context}} \\*The Graphics context abstraction }{\pageref{classlambda_1_1core_1_1renderer_1_1GraphicsContext}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1imgui_1_1ImGuiLayer}{lambda\+::core\+::imgui\+::\+Im\+Gui\+Layer}} \\*The base Im\+Gui layer used for rendering all other Im\+Gui components }{\pageref{classlambda_1_1core_1_1imgui_1_1ImGuiLayer}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1renderer_1_1IndexBuffer}{lambda\+::core\+::renderer\+::\+Index\+Buffer}} \\*A general abstraction of an Index Buffer }{\pageref{classlambda_1_1core_1_1renderer_1_1IndexBuffer}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1input_1_1Input}{lambda\+::core\+::input\+::\+Input}} \\*The generic input system for getting input data from applications built on lambda }{\pageref{classlambda_1_1core_1_1input_1_1Input}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1events_1_1KeyEvent}{lambda\+::core\+::events\+::\+Key\+Event}} \\*The Base Key \mbox{\hyperlink{classlambda_1_1core_1_1events_1_1Event}{Event}} used for other Key Events }{\pageref{classlambda_1_1core_1_1events_1_1KeyEvent}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1events_1_1KeyPressedEvent}{lambda\+::core\+::events\+::\+Key\+Pressed\+Event}} \\*An \mbox{\hyperlink{classlambda_1_1core_1_1events_1_1Event}{Event}} generated whenever a key is pressed within an application that is running lambda }{\pageref{classlambda_1_1core_1_1events_1_1KeyPressedEvent}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1events_1_1KeyReleasedEvent}{lambda\+::core\+::events\+::\+Key\+Released\+Event}} \\*An \mbox{\hyperlink{classlambda_1_1core_1_1events_1_1Event}{Event}} generated whenever a key is released within an application that is running lambda }{\pageref{classlambda_1_1core_1_1events_1_1KeyReleasedEvent}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1events_1_1KeyTypedEvent}{lambda\+::core\+::events\+::\+Key\+Typed\+Event}} \\*An \mbox{\hyperlink{classlambda_1_1core_1_1events_1_1Event}{Event}} generated whenever a key is typed within an application that is running lambda. (Keys typed do not track any repeat counts.) }{\pageref{classlambda_1_1core_1_1events_1_1KeyTypedEvent}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1layers_1_1Layer}{lambda\+::core\+::layers\+::\+Layer}} \\*The lambda \mbox{\hyperlink{classlambda_1_1core_1_1layers_1_1Layer}{Layer}} abstraction. Primarily used for direct access into lambdas tick and event system }{\pageref{classlambda_1_1core_1_1layers_1_1Layer}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1layers_1_1LayerStack}{lambda\+::core\+::layers\+::\+Layer\+Stack}} \\*A Stack based structure for lambda to manage layers in }{\pageref{classlambda_1_1core_1_1layers_1_1LayerStack}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1util_1_1Log}{lambda\+::core\+::util\+::\+Log}} \\*The container class for managing static instances of the engine and client loggers }{\pageref{classlambda_1_1core_1_1util_1_1Log}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1events_1_1MouseButtonEvent}{lambda\+::core\+::events\+::\+Mouse\+Button\+Event}} \\*The base event class for all events mouse button related }{\pageref{classlambda_1_1core_1_1events_1_1MouseButtonEvent}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1events_1_1MouseButtonPressedEvent}{lambda\+::core\+::events\+::\+Mouse\+Button\+Pressed\+Event}} \\*An event generated whenever a Mouse button is pressed within an application that is running lambda }{\pageref{classlambda_1_1core_1_1events_1_1MouseButtonPressedEvent}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1events_1_1MouseButtonReleasedEvent}{lambda\+::core\+::events\+::\+Mouse\+Button\+Released\+Event}} \\*An event generated whenever a Mouse button is released within an application that is running lambda }{\pageref{classlambda_1_1core_1_1events_1_1MouseButtonReleasedEvent}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1events_1_1MouseMovedEvent}{lambda\+::core\+::events\+::\+Mouse\+Moved\+Event}} \\*An event generated whenever a mouse is moved within an application that is running lambda }{\pageref{classlambda_1_1core_1_1events_1_1MouseMovedEvent}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1events_1_1MouseScrolledEvent}{lambda\+::core\+::events\+::\+Mouse\+Scrolled\+Event}} \\*An event generated whenever a mouse is scrolled within an application that is running lambda }{\pageref{classlambda_1_1core_1_1events_1_1MouseScrolledEvent}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1platform_1_1opengl_1_1OpenGLContext}{lambda\+::platform\+::opengl\+::\+Open\+G\+L\+Context}} }{\pageref{classlambda_1_1platform_1_1opengl_1_1OpenGLContext}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1platform_1_1opengl_1_1OpenGLIndexBuffer}{lambda\+::platform\+::opengl\+::\+Open\+G\+L\+Index\+Buffer}} }{\pageref{classlambda_1_1platform_1_1opengl_1_1OpenGLIndexBuffer}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1platform_1_1opengl_1_1OpenGLRendererAPI}{lambda\+::platform\+::opengl\+::\+Open\+G\+L\+Renderer\+A\+PI}} \\*The Rendering implementation for Open\+GL }{\pageref{classlambda_1_1platform_1_1opengl_1_1OpenGLRendererAPI}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1platform_1_1opengl_1_1OpenGLShader}{lambda\+::platform\+::opengl\+::\+Open\+G\+L\+Shader}} }{\pageref{classlambda_1_1platform_1_1opengl_1_1OpenGLShader}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1platform_1_1opengl_1_1OpenGLTexture2D}{lambda\+::platform\+::opengl\+::\+Open\+G\+L\+Texture2D}} \\*The opengl 2D texture implementation }{\pageref{classlambda_1_1platform_1_1opengl_1_1OpenGLTexture2D}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1platform_1_1opengl_1_1OpenGLVertexArray}{lambda\+::platform\+::opengl\+::\+Open\+G\+L\+Vertex\+Array}} \\*The abstraction for representing Vertex arrays and their sub components }{\pageref{classlambda_1_1platform_1_1opengl_1_1OpenGLVertexArray}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1platform_1_1opengl_1_1OpenGLVertexBuffer}{lambda\+::platform\+::opengl\+::\+Open\+G\+L\+Vertex\+Buffer}} }{\pageref{classlambda_1_1platform_1_1opengl_1_1OpenGLVertexBuffer}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1renderer_1_1OrthographicCamera}{lambda\+::core\+::renderer\+::\+Orthographic\+Camera}} \\*An orthographic camera implementation for the 2D engine }{\pageref{classlambda_1_1core_1_1renderer_1_1OrthographicCamera}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1OrthographicCameraController}{lambda\+::core\+::\+Orthographic\+Camera\+Controller}} }{\pageref{classlambda_1_1core_1_1OrthographicCameraController}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1renderer_1_1RenderCommand}{lambda\+::core\+::renderer\+::\+Render\+Command}} \\*An interface for issuing commands to the current rendering A\+PI that is being used with lambda }{\pageref{classlambda_1_1core_1_1renderer_1_1RenderCommand}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1renderer_1_1Renderer}{lambda\+::core\+::renderer\+::\+Renderer}} \\*The primary interface used for managing }{\pageref{classlambda_1_1core_1_1renderer_1_1Renderer}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1renderer_1_1RendererAPI}{lambda\+::core\+::renderer\+::\+Renderer\+A\+PI}} \\*The abstract representation of rendering features and functions supported by Lambda }{\pageref{classlambda_1_1core_1_1renderer_1_1RendererAPI}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1util_1_1Reverse}{lambda\+::core\+::util\+::\+Reverse$<$ Container $>$}} }{\pageref{classlambda_1_1core_1_1util_1_1Reverse}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1util_1_1Reverse}{Reverse}} \\*Provides a clean interface for iterating through any container that implements rbegin and rend }{\pageref{classlambda_1_1util_1_1Reverse}}{}
\item\contentsline{section}{\mbox{\hyperlink{classShader}{Shader}} \\*The \mbox{\hyperlink{classShader}{Shader}} A\+PI }{\pageref{classShader}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1renderer_1_1Shader}{lambda\+::core\+::renderer\+::\+Shader}} \\*A generic \mbox{\hyperlink{classlambda_1_1core_1_1renderer_1_1Shader}{Shader}} A\+PI }{\pageref{classlambda_1_1core_1_1renderer_1_1Shader}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1renderer_1_1ShaderLibrary}{lambda\+::core\+::renderer\+::\+Shader\+Library}} \\*A library for managing many different shaders }{\pageref{classlambda_1_1core_1_1renderer_1_1ShaderLibrary}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1renderer_1_1Texture}{lambda\+::core\+::renderer\+::\+Texture}} \\*The abstract texture A\+PI }{\pageref{classlambda_1_1core_1_1renderer_1_1Texture}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1renderer_1_1Texture2D}{lambda\+::core\+::renderer\+::\+Texture2D}} \\*The 2D \mbox{\hyperlink{classlambda_1_1core_1_1renderer_1_1Texture}{Texture}} A\+PI }{\pageref{classlambda_1_1core_1_1renderer_1_1Texture2D}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1util_1_1Time}{Time}} \\*A wrapper for working with \mbox{\hyperlink{classlambda_1_1util_1_1Time}{Time}} within the game engine. Uses std\+::steady\+\_\+clock for a platform independent Monotonic clock }{\pageref{classlambda_1_1util_1_1Time}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1util_1_1Time}{lambda\+::core\+::util\+::\+Time}} }{\pageref{classlambda_1_1core_1_1util_1_1Time}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1util_1_1TimeStep}{lambda\+::core\+::util\+::\+Time\+Step}} }{\pageref{classlambda_1_1core_1_1util_1_1TimeStep}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1util_1_1TimeStep}{Time\+Step}} \\*The timestep between two time intervals. Primarily used for layers to consistently update the engine }{\pageref{classlambda_1_1util_1_1TimeStep}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1renderer_1_1VertexArray}{lambda\+::core\+::renderer\+::\+Vertex\+Array}} \\*The abstract \mbox{\hyperlink{classlambda_1_1core_1_1renderer_1_1VertexArray}{Vertex\+Array}} A\+PI }{\pageref{classlambda_1_1core_1_1renderer_1_1VertexArray}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1renderer_1_1VertexBuffer}{lambda\+::core\+::renderer\+::\+Vertex\+Buffer}} \\*A general abstraction of Vertex Buffer }{\pageref{classlambda_1_1core_1_1renderer_1_1VertexBuffer}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1Window}{Window}} \\*The generic window implementation that allows platform specific window A\+P\+Is to expose generic window functionality without users having to know the window system }{\pageref{classlambda_1_1Window}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1Window}{lambda\+::core\+::\+Window}} }{\pageref{classlambda_1_1core_1_1Window}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1events_1_1WindowCloseEvent}{lambda\+::core\+::events\+::\+Window\+Close\+Event}} \\*An \mbox{\hyperlink{classlambda_1_1core_1_1events_1_1Event}{Event}} generated when the \mbox{\hyperlink{classlambda_1_1core_1_1Window}{Window}} has closed }{\pageref{classlambda_1_1core_1_1events_1_1WindowCloseEvent}}{}
\item\contentsline{section}{\mbox{\hyperlink{structlambda_1_1WindowProperties}{Window\+Properties}} \\*Generic \mbox{\hyperlink{classlambda_1_1Window}{Window}} properties used to create platform specific windows }{\pageref{structlambda_1_1WindowProperties}}{}
\item\contentsline{section}{\mbox{\hyperlink{structlambda_1_1core_1_1WindowProperties}{lambda\+::core\+::\+Window\+Properties}} }{\pageref{structlambda_1_1core_1_1WindowProperties}}{}
\item\contentsline{section}{\mbox{\hyperlink{classlambda_1_1core_1_1events_1_1WindowResizeEvent}{lambda\+::core\+::events\+::\+Window\+Resize\+Event}} \\*An \mbox{\hyperlink{classlambda_1_1core_1_1events_1_1Event}{Event}} generated when the \mbox{\hyperlink{classlambda_1_1core_1_1Window}{Window}} has resized }{\pageref{classlambda_1_1core_1_1events_1_1WindowResizeEvent}}{}
\end{DoxyCompactList}
