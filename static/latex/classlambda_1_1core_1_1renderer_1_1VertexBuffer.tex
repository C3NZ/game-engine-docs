\hypertarget{classlambda_1_1core_1_1renderer_1_1VertexBuffer}{}\doxysection{lambda\+::core\+::renderer\+::Vertex\+Buffer Class Reference}
\label{classlambda_1_1core_1_1renderer_1_1VertexBuffer}\index{lambda::core::renderer::VertexBuffer@{lambda::core::renderer::VertexBuffer}}


Inheritance diagram for lambda\+::core\+::renderer\+::Vertex\+Buffer\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=220pt]{classlambda_1_1core_1_1renderer_1_1VertexBuffer__inherit__graph}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \mbox{\hyperlink{classlambda_1_1core_1_1renderer_1_1VertexBuffer_af5bbf1ffa2bc786f4f5f13ca7edba80f}{Bind}} () const =0
\begin{DoxyCompactList}\small\item\em Bind the vertex buffer to the current rendering context. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classlambda_1_1core_1_1renderer_1_1VertexBuffer_a25fa0ac770d6ef22a3695d2979878a02}{Unbind}} () const =0
\begin{DoxyCompactList}\small\item\em Unbind the vertex buffer to the current rendering context. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classlambda_1_1core_1_1renderer_1_1VertexBuffer_a0473c3631c8d64b005725e886185e8d2}\label{classlambda_1_1core_1_1renderer_1_1VertexBuffer_a0473c3631c8d64b005725e886185e8d2}} 
virtual const \mbox{\hyperlink{classlambda_1_1core_1_1renderer_1_1BufferLayout}{Buffer\+Layout}} \& \mbox{\hyperlink{classlambda_1_1core_1_1renderer_1_1VertexBuffer_a0473c3631c8d64b005725e886185e8d2}{Get\+Layout}} () const =0
\begin{DoxyCompactList}\small\item\em Get the \mbox{\hyperlink{classlambda_1_1core_1_1renderer_1_1BufferLayout}{Buffer\+Layout}} tied to the current \mbox{\hyperlink{classlambda_1_1core_1_1renderer_1_1VertexBuffer}{Vertex\+Buffer}}. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classlambda_1_1core_1_1renderer_1_1VertexBuffer_acdb20afa541169e8a7b9b21c99e1e219}\label{classlambda_1_1core_1_1renderer_1_1VertexBuffer_acdb20afa541169e8a7b9b21c99e1e219}} 
virtual void \mbox{\hyperlink{classlambda_1_1core_1_1renderer_1_1VertexBuffer_acdb20afa541169e8a7b9b21c99e1e219}{Set\+Layout}} (const \mbox{\hyperlink{classlambda_1_1core_1_1renderer_1_1BufferLayout}{Buffer\+Layout}} \&)=0
\begin{DoxyCompactList}\small\item\em Set the \mbox{\hyperlink{classlambda_1_1core_1_1renderer_1_1BufferLayout}{Buffer\+Layout}} for the current \mbox{\hyperlink{classlambda_1_1core_1_1renderer_1_1VertexBuffer}{Vertex\+Buffer}}. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static memory\+::\+Shared$<$ \mbox{\hyperlink{classlambda_1_1core_1_1renderer_1_1VertexBuffer}{Vertex\+Buffer}} $>$ \mbox{\hyperlink{classlambda_1_1core_1_1renderer_1_1VertexBuffer_a461601fdd3b858c65803f49ef5fbd02b}{Create}} (float $\ast$vertices, uint32\+\_\+t size)
\begin{DoxyCompactList}\small\item\em Creates a \mbox{\hyperlink{classlambda_1_1core_1_1renderer_1_1VertexBuffer}{Vertex\+Buffer}} through the Graphics A\+PI that is being used at compile time. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classlambda_1_1core_1_1renderer_1_1VertexBuffer_af5bbf1ffa2bc786f4f5f13ca7edba80f}\label{classlambda_1_1core_1_1renderer_1_1VertexBuffer_af5bbf1ffa2bc786f4f5f13ca7edba80f}} 
\index{lambda::core::renderer::VertexBuffer@{lambda::core::renderer::VertexBuffer}!Bind@{Bind}}
\index{Bind@{Bind}!lambda::core::renderer::VertexBuffer@{lambda::core::renderer::VertexBuffer}}
\doxysubsubsection{\texorpdfstring{Bind()}{Bind()}}
{\footnotesize\ttfamily Vertex\+Buffer\+::\+Bind (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [pure virtual]}}



Bind the vertex buffer to the current rendering context. 

The binding process is entirely dependent upon the grahpics A\+PI. However, it should be noted that this function needs to be called by the user whenever they\textquotesingle{}re trying to bind the buffer to the render A\+PI. 

Implemented in \mbox{\hyperlink{classlambda_1_1platform_1_1opengl_1_1OpenGLVertexBuffer_a2ebb10a0bfcc9a21f37df02a1b0edd1d}{lambda\+::platform\+::opengl\+::\+Open\+G\+L\+Vertex\+Buffer}}.

\mbox{\Hypertarget{classlambda_1_1core_1_1renderer_1_1VertexBuffer_a461601fdd3b858c65803f49ef5fbd02b}\label{classlambda_1_1core_1_1renderer_1_1VertexBuffer_a461601fdd3b858c65803f49ef5fbd02b}} 
\index{lambda::core::renderer::VertexBuffer@{lambda::core::renderer::VertexBuffer}!Create@{Create}}
\index{Create@{Create}!lambda::core::renderer::VertexBuffer@{lambda::core::renderer::VertexBuffer}}
\doxysubsubsection{\texorpdfstring{Create()}{Create()}}
{\footnotesize\ttfamily Vertex\+Buffer\+::\+Create (\begin{DoxyParamCaption}\item[{float $\ast$}]{vertices,  }\item[{uint32\+\_\+t}]{size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Creates a \mbox{\hyperlink{classlambda_1_1core_1_1renderer_1_1VertexBuffer}{Vertex\+Buffer}} through the Graphics A\+PI that is being used at compile time. 


\begin{DoxyParams}{Parameters}
{\em vertices} & -\/ a pointer to an array of vertices to be registered. \\
\hline
{\em size} & -\/ The size of the vertices in bytes. This is the primary method of creating platform independent vertex buffers and what should be used by users to create Vertex Buffers that are compatible with the rendering A\+PI. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classlambda_1_1core_1_1renderer_1_1VertexBuffer_a25fa0ac770d6ef22a3695d2979878a02}\label{classlambda_1_1core_1_1renderer_1_1VertexBuffer_a25fa0ac770d6ef22a3695d2979878a02}} 
\index{lambda::core::renderer::VertexBuffer@{lambda::core::renderer::VertexBuffer}!Unbind@{Unbind}}
\index{Unbind@{Unbind}!lambda::core::renderer::VertexBuffer@{lambda::core::renderer::VertexBuffer}}
\doxysubsubsection{\texorpdfstring{Unbind()}{Unbind()}}
{\footnotesize\ttfamily Vertex\+Buffer\+::\+Unbind (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [pure virtual]}}



Unbind the vertex buffer to the current rendering context. 

The unbinding process is entirely dependent upon the grahpics A\+PI. However, it should be noted that this function needs to be called by the user whenever they\textquotesingle{}re trying to unbind the buffer from the render A\+PI. (For cleaning up anything still in memory.) 

Implemented in \mbox{\hyperlink{classlambda_1_1platform_1_1opengl_1_1OpenGLVertexBuffer_a0cc6f0080481c97c31640f28b2c004ea}{lambda\+::platform\+::opengl\+::\+Open\+G\+L\+Vertex\+Buffer}}.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
lambda/src/core/renderer/\mbox{\hyperlink{Buffer_8h}{Buffer.\+h}}\item 
lambda/src/core/renderer/Buffer.\+cpp\end{DoxyCompactItemize}
